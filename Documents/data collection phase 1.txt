FINALIZED CONSTRAINTS (LOCKED)

These are now part of your methodology:

ğŸ“Œ Post collection

Minimum posts: 100

Maximum posts: 150

Selection: Most recent posts only

Content type: Reels only

Niche: Single niche (already fixed)

ğŸ“Œ Comment sampling (future phase)

Comments per post: 50

Visible comments only

Top-loaded sample (no guarantee of chronological completeness)

We will not violate these later.

ğŸ§© PHASE 1 â€” POST INDEXING

(Playwright logic design â€” NO CODE)

ğŸ¯ Objective of Phase 1

Collect 100â€“150 Reel post URLs from a creatorâ€™s profile
without opening posts or scraping metrics.

ğŸ§  High-Level Flow (One Sentence)

Open creator profile â†’ switch to Reels â†’ scroll slowly â†’ collect post URLs â†’ stop at 150 or end.

ğŸªœ STEP-BY-STEP PLAYWRIGHT LOGIC
ğŸ”¹ STEP 1: Launch Browser & Session

What happens:

Playwright opens real Chrome

Uses existing logged-in Instagram session

No headless mode

Why:

Avoids login loops

Looks human

Stable for scrolling

ğŸ”¹ STEP 2: Navigate to Creator Profile

Playwright goes to:

https://www.instagram.com/<creator_username>/


Then it:

Waits until profile grid loads

Verifies profile is public

Reads:

visible follower count (string only, e.g. â€œ1.2Mâ€)

verified badge (if present)

ğŸ“Œ No scrolling yet.

ğŸ”¹ STEP 3: Switch to â€œReelsâ€ Tab

Playwright:

Clicks Reels tab

Waits until Reel grid is visible

Validation:

Ensures content is reels only

If no reels â†’ abort this creator

This protects your dataset quality.

ğŸ”¹ STEP 4: Initialize Post URL Collector

Internally, Playwright maintains:

An empty set (to avoid duplicates)

A counter starting at 0

Example (conceptual):

collectedPostURLs = Set()

ğŸ”¹ STEP 5: Controlled Scrolling Loop

This is the most important part.

Scroll behavior:

Scroll down by ~1 viewport

Wait 1.5â€“2.5 seconds

Let Instagram load more posts

Repeat

This mimics human scrolling.

ğŸ”¹ STEP 6: Extract Reel URLs After Each Scroll

After each scroll:

Playwright scans visible reel cards

Extracts:

/p/<post_id>/ URLs only

Adds new URLs to the set

Rules:

Ignore duplicates

Ignore non-reel URLs

ğŸ”¹ STEP 7: Stop Conditions (CRITICAL)

Scrolling stops immediately when any one condition is met:

âœ… Condition A â€” Max reached
collectedPostURLs.length >= 150

âœ… Condition B â€” End of content

No new posts after 3 consecutive scrolls

âŒ Condition C â€” Min not reached

If total collected < 100:

Log warning

Still proceed (but flagged as low coverage)

ğŸ“Œ This is honest and evaluatable.

ğŸ”¹ STEP 8: Freeze & Finalize Post Index

Once scrolling stops:

Playwright:

Sorts posts by appearance order

Assigns position_on_profile

Trims list to:

100â€“150 posts only

This creates a deterministic index.

ğŸ”¹ STEP 9: Save PHASE 1 JSON

Final output:

One JSON file per creator

Filename format:

post_index_<creator>_<YYYY-MM-DD>.json


This file becomes input for Phase 2.

ğŸ§  Why This Phase Design Is VERY STRONG
âœ” Reproducible

Same creator + same day â†’ similar output

âœ” Auditable

You can show:

why you stopped

how many posts existed

how many were selected

âœ” Safe

No aggressive automation

No hidden endpoints

No data inference

ğŸ”— How This Supports Phase 2 (Later)

Phase 2 will:

Read this JSON

Loop through only these URLs

Collect:

metrics

caption

50 comments per post

So Phase 1 becomes a contract.